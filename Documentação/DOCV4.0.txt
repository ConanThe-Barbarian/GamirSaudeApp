DOCUMENTA√á√ÉO T√âCNICA FINAL DE ARQUITETURA E FUNCIONALIDADESPROJETO: GAMIR SA√öDE üöÄVers√£o Final: 5.1 (Fluxo de Agendamento Est√°vel com Autentica√ß√£o e Verifica√ß√£o de Conta)Autor: IGRIS V1.0 (Sistema de Intelig√™ncia T√°tica Integrada)Data: 16 de Outubro de 2025Prop√≥sito: Este documento √© o registro definitivo e detalhado da arquitetura do aplicativo Gamir Sa√∫de, dos seus fluxos de neg√≥cio e da fun√ß√£o exata de cada arquivo fornecido. Serve como a fonte de verdade absoluta para o legado do projeto.I. ACESSOS E ABRANG√äNCIA DA INTELIG√äNCIAO sistema de Intelig√™ncia T√°tica Igris absorveu a totalidade da solu√ß√£o, abrangendo tanto a aplica√ß√£o m√≥vel (.NET MAUI) quanto o Backend (API RESTful em .NET 8).Camada da Solu√ß√£oProjetos AcessadosTipo de Arquivos AcessadosFrontendGamirSaudeAppViews (.xaml, .xaml.cs), ViewModels (.cs), Models (.cs), Services (.cs), Behaviors (.cs)BackendGamirSaude.API, GamirSaude.Application, GamirSaude.Domain, GamirSaude.InfrastructureControllers (.cs), DTOs (.cs), Entities (.cs), DbContext (.cs), Repositories (.cs), Arquivos XML de Estrutura de Banco de DadosII. FILOSOFIA E ARQUITETURA GERALA estrat√©gia de constru√ß√£o foi a separa√ß√£o total de responsabilidades.2.1. Backend (API RESTful - C# .NET 8 / Clean Architecture)O backend atua como o C√©rebro de A√ßo, executando a l√≥gica de neg√≥cio e interagindo com o SQL Server.ProjetoProp√≥sitoEntidades/DTOs ChaveGamirSaude.DomainO Cora√ß√£o Sagrado. Cont√©m as leis do universo. Define as classes de Entidades (tabelas) e Interfaces.Agenda.cs, Paciente.cs, Cad_UsuarioApp.cs, AgendaWebView.cs, PrestadorMedico.cs.GamirSaude.ApplicationO T√°tico. Define a estrat√©gia e os contratos de comunica√ß√£o.AgendamentoRequestDto.cs, HorariosDisponiveisRequest.cs, LoginRequestDto.cs, RegisterRequestDto.cs.GamirSaude.InfrastructureA Sala de M√°quinas. Implementa o acesso a dados.GamirSaudeDbContext.cs (mapeia todas as entidades e views), PacienteRepository.cs.GamirSaude.APIA Linha de Frente. Exp√µe os Controllers e seus Endpoints.AuthController.cs, AgendamentoController.cs, Program.cs.2.2. Frontend (App M√≥vel - .NET MAUI / MVVM)O frontend √© a Experi√™ncia do Usu√°rio, seguindo o padr√£o MVVM (Model-View-ViewModel).CamadaProp√≥sitoArquivos ChaveViewsAs telas (.xaml) e a conex√£o com o ViewModel (.xaml.cs).LoginPage.xaml, DashboardPage.xaml, MedicosDisponiveisPage.xaml, RegisterPage.xaml, VerifyAccountPage.xaml.ViewModelsO C√©rebro de cada tela. Cont√©m a l√≥gica de neg√≥cio e os comandos. Utiliza o CommunityToolkit.Mvvm.LoginViewModel.cs, DashboardViewModel.cs, MedicosDisponiveisViewModel.cs, VerifyAccountViewModel.cs.ServicesA camada de comunica√ß√£o e gest√£o de estado global.GamirApiService.cs, UserDataService.cs.III. FLUXOS E FUNCIONALIDADES DETALHADAS3.1. FLUXO 1: CADASTRO DE NOVO USU√ÅRIO (Blindagem da Procedure)Prop√≥sito: Registrar novos usu√°rios do aplicativo na tabela Cad_UsuarioApp, atribuindo-lhes um status padr√£o de "Particular" (IDs fixos 33 e 31 - regra de neg√≥cio n√£o persistida no DB) para satisfazer as exig√™ncias do agendamento futuro.ComponenteA√ß√µes T√°ticas DetalhadasRegisterPage.xamlInterface que coleta Nome, CPF (com m√°scara via CpfFormattingBehavior), Email, Senha, Data de Nascimento e Sexo.RegisterViewModel.csValida se senhas coincidem e se campos obrigat√≥rios est√£o preenchidos. Remove a m√°scara do CPF e do Telefone (.Where(char.IsDigit)) antes de enviar. Envia apenas a primeira letra do Sexo (.Substring(0, 1)) para a API.AuthController.cs (Register)1. Recebe o RegisterRequestDto. 2. Valida se CPF e Email s√£o √∫nicos. 3. Cria um Hash BCrypt (BCrypt.Net.BCrypt.HashPassword) da senha. 4. Cria e salva a entidade Cad_UsuarioApp com ContaVerificada = false e idPacienteGamir = null. O CPF √© salvo apenas com n√∫meros (new string(request.Cpf?.Where...) para evitar erros de busca no login.3.2. FLUXO 2: LOGIN DE USU√ÅRIO (Autentica√ß√£o Segura)Prop√≥sito: Autenticar o usu√°rio contra o Cad_UsuarioApp e carregar o estado de sua conta, incluindo o idPacienteGamir.ComponenteA√ß√µes T√°ticas DetalhadasLoginViewModel.csCaptura CPF e Senha. Utiliza o m√©todo de apoio GetCpfNumerico() para remover a m√°scara. Chama o LoginAsync no servi√ßo.AuthController.cs (Login)1. Busca o usuarioApp na tabela Cad_UsuarioApp pelo CPF num√©rico. 2. Verifica a senha usando o hash (BCrypt.Net.BCrypt.Verify(senha, hash_db)). 3. Se bem-sucedido, retorna os dados do usu√°rio, incluindo ContaVerificada e idPacienteGamir.UserDataService.csArmazena o estado do usu√°rio logado: IdUserApp, NomeUsuario, EmailUsuario, ContaVerificada, e o crucial IdPacienteGamir. A propriedade IdPaciente √© uma conveni√™ncia que retorna IdPacienteGamir ?? 0, sendo a chave para todas as requisi√ß√µes de agendamento.3.3. FLUXO 3: VERIFICA√á√ÉO DE CONTA (Cria√ß√£o da Ponte Legada)Prop√≥sito: Ligar um usu√°rio do aplicativo a um paciente existente no sistema legado, obtendo o idPacienteGamir necess√°rio para o agendamento.ComponenteA√ß√µes T√°ticas DetalhadasDashboardPage.xamlExibe um Border laranja de aviso e um bot√£o "Verificar Agora" que s√≥ √© vis√≠vel se ContaNaoVerificada for true.VerifyAccountViewModel.csComando SendCode: Chama a API para gerar e salvar o c√≥digo no banco, usando o EmailUsuario do UserDataService. Comando Verify: Envia o c√≥digo digitado e o e-mail para a API. Se bem-sucedido, atualiza o status localmente e navega de volta para a Dashboard com o par√¢metro ?refresh=true para remover o aviso.AuthController.cs (Send Code)Gera um c√≥digo de 6 d√≠gitos (new Random().Next(100000, 999999)). Salva o c√≥digo e a DataExpiracaoCodigo (15 minutos) no Cad_UsuarioApp.AuthController.cs (Verify Account)1. Valida se o c√≥digo n√£o expirou e se o c√≥digo digitado coincide com o do DB. 2. Busca o paciente legado (_context.Pacientes.FirstOrDefaultAsync) pelo e-mail. 3. Se encontrado, define usuarioApp.ContaVerificada = true e usuarioApp.idPacienteGamir = pacienteLegado.IdPaciente.3.4. FLUXO 4: AGENDAMENTO DE CONSULTA E EXAME (Transa√ß√£o Final)Prop√≥sito: Gerar a requisi√ß√£o de agendamento, utilizando o IdProcedimento din√¢mico e o IdPaciente verificado, e persistir o registro na tabela Cad_Agenda.ComponenteA√ß√µes T√°ticas DetalhadasColeta de Par√¢metrosConsulta: AgendarConsultaViewModel.cs envia EspecialidadeNome e IdProcedimento. Exame: ExamesEspecificosViewModel.cs envia Nome do exame e IdProcedimento.Tela de Agendamento (MedicosDisponiveis)Recebe o IdProcedimento via [QueryProperty]. Utiliza esse IdProcedimento em duas requisi√ß√µes cr√≠ticas: 1. GetHorariosDisponiveisAsync (para calcular slots do procedimento espec√≠fico). 2. AgendarConsultaCommand (na requisi√ß√£o final).AgendamentoController.cs (Final)1. Recebe o AgendamentoRequestDto. 2. Cria a entidade Agenda. 3. Atribui o IdPaciente (vindo do UserDataService do app) e o IdProcedimentoTussNomenclatura (ID din√¢mico). 4. Executa a inser√ß√£o direta na tabela Cad_Agenda via _context.Agendas.Add(novoAgendamento) e await _context.SaveChangesAsync(). NOTA: O sucesso desta opera√ß√£o confirma que a l√≥gica de neg√≥cio foi abstra√≠da para o C#, eliminando a necessidade da Procedure legada para a inser√ß√£o b√°sica.