üí£ DOCUMENTA√á√ÉO MESTRA DE PROJETO: A SAGA DO APLICATIVO GAMIR SA√öDE üöÄ
Vers√£o: 4.0 (Marco: Fluxo de Agendamento Din√¢mico Conclu√≠do)
Data: 08 de Outubro de 2025
Autor: VORTEX V3.0 (Arquiteto de Solu√ß√µes e Mentor Full-Stack)
Prop√≥sito: Este documento √© o registro definitivo e absurdamente detalhado da jornada de desenvolvimento do aplicativo Gamir Sa√∫de. Ele disseca a arquitetura, o c√≥digo-fonte, as decis√µes cr√≠ticas e o hist√≥rico de cada bug esmagado, servindo como a fonte da verdade absoluta para qualquer desenvolvedor ou IA que assuma este legado.

I. FILOSOFIA E ARQUITETURA GERAL: A FUNDA√á√ÉO
A estrat√©gia desde o in√≠cio foi a separa√ß√£o total de responsabilidades. O sistema √© dividido em duas fortalezas que se comunicam por uma ponte RESTful.

1.1. O Backend (API RESTful): O C√©rebro de A√ßo
Constru√≠do com .NET 8, C# 12 e Entity Framework Core 8, ele segue a Clean Architecture, uma disciplina de guerra que garante que a l√≥gica de neg√≥cio n√£o seja contaminada por detalhes de infraestrutura.

GamirSaude.Domain (O Cora√ß√£o Sagrado):

Prop√≥sito: Cont√©m as leis do nosso universo. As classes de Entidades (espelhos das tabelas do banco) e as Interfaces de reposit√≥rios vivem aqui. Este projeto n√£o conhece e n√£o depende de ningu√©m.

Classes Cruciais Criadas: Paciente.cs, Especialidade.cs, PrestadorMedico.cs, Agenda.cs, PrestadorMedicoEspecialidade.cs, e a mais importante: AgendaWebView.cs.

Mapeamento de Dados: Usamos "Data Annotations" ([Table], [Key], [Column]) para mapear precisamente as classes C# √†s tabelas e colunas com nomes legados do banco SQL Server. Esta foi a chave para resolver 90% dos erros de banco de dados.

GamirSaude.Infrastructure (As Ferramentas Pesadas):

Prop√≥sito: A sala de m√°quinas. Cont√©m o GamirSaudeDbContext.cs, que √© o tradutor oficial entre C# e SQL, e as implementa√ß√µes concretas dos reposit√≥rios (ex: PacienteRepository.cs). √â aqui que o Entity Framework Core faz sua m√°gica.

GamirSaude.Application (O T√°tico):

Prop√≥sito: Onde a estrat√©gia √© definida. Cont√©m a l√≥gica de neg√≥cio e, crucialmente, os DTOs (Data Transfer Objects).

Pastas Criadas: DTOs.

Classes Cruciais Criadas: DiasDisponiveisRequest.cs, HorariosDisponiveisRequest.cs, AgendamentoRequestDto.cs. Estas classes s√£o os "envelopes" que carregam as informa√ß√µes entre o frontend e o backend.

GamirSaude.API (A Linha de Frente):

Prop√≥sito: A interface com o mundo exterior. Exp√µe os Controllers e seus Endpoints (as URLs que o nosso app chama).

Controllers Criados: AuthController.cs e AgendamentoController.cs.

1.2. O Frontend (App M√≥vel): A Experi√™ncia do Usu√°rio
Constru√≠do com .NET MAUI, ele segue o padr√£o MVVM (Model-View-ViewModel), garantindo que a interface (View) seja completamente burra, apenas um reflexo do estado do seu c√©rebro (ViewModel).

Models: Classes simples que s√£o moldes para os dados recebidos da API (ex: Medico.cs, DiaDisponivel.cs).

Views: As telas, constru√≠das em XAML. Cont√™m a apar√™ncia e o layout.

ViewModels: O c√©rebro de cada tela. Cont√©m toda a l√≥gica e estado (propriedades). Usamos a biblioteca CommunityToolkit.Mvvm para acelerar com os atributos [ObservableProperty] e [RelayCommand].

Services: A camada de comunica√ß√£o. GamirApiService.cs √© o nosso √∫nico ponto de contato com o backend. UserDataService.cs √© a mem√≥ria global que guarda os dados do paciente logado.

II. A JORNADA DE CONSTRU√á√ÉO: CADA TABELA, CADA CLIQUE
2.1. A Tabela Mestra: vw_cad_prestadorMedicoEspecialidadeAgendaWeb
Esta VIEW no SQL Server se tornou a espinha dorsal de todo o fluxo de agendamento. Ela √© um JOIN pr√©-compilado de m√∫ltiplas tabelas (Cad_PrestadorMedico, Cad_PrestadorMedicoEspecialidade, etc.) e cont√©m todas as informa√ß√µes necess√°rias em um s√≥ lugar:

Dados do m√©dico (PrestadorMedico, idPrestadorMedico)

Dados da especialidade (EspecialidadeCBOS)

Regras de expediente: Dias da semana que trabalha (Segunda, Terca...), hor√°rios de in√≠cio e fim (SegundaHoraInicio, SegundaHoraFim), e os cruciais hor√°rios de almo√ßo (SegundaAlmoco, SegundaAlmocoinicio...).

Regras de capacidade: Quantidade m√°xima de agendamentos por dia (SegundaQuantidadeMaxima).

Dura√ß√£o da consulta: O campo EscalaAgenda, que define quantos minutos dura cada slot de agendamento.

Li√ß√£o Aprendida: Centralizar a l√≥gica de busca de dados em uma View no banco simplificou drasticamente o c√≥digo C# no backend.

2.2. O Fluxo de Agendamento: Passo a Passo Detalhado
Login (LoginPage -> LoginViewModel):

O usu√°rio insere CPF/Senha.

O LoginCommand chama GamirApiService.LoginAsync().

O servi√ßo faz um POST para /api/auth/login.

Se o login for bem-sucedido, a API retorna os dados do paciente.

Ponto Cr√≠tico: Os dados IdPaciente e Nome s√£o salvos no UserDataService, que foi registrado como Singleton no MauiProgram.cs para que essa informa√ß√£o persista durante toda a sess√£o do app.

A navega√ß√£o Shell.Current.GoToAsync($"//{nameof(DashboardPage)}") leva √† tela principal.

Dashboard (DashboardPage -> DashboardViewModel):

O nome do usu√°rio √© exibido, lido do UserDataService.

O clique em "Agendar consulta" dispara o AgendarConsultaCommand.

Navega para AgendarConsultaPage.

Sele√ß√£o de Especialidade (AgendarConsultaPage -> AgendarConsultaViewModel):

PageAppearingCommand √© disparado.

Chama GamirApiService.GetEspecialidadesAsync().

O servi√ßo faz um GET para /api/agendamento/especialidades.

L√≥gica de Backend: O endpoint agora consulta a AgendaWebView, usa DistinctBy(v => v.Nome) na mem√≥ria para garantir que n√£o haja especialidades repetidas e retorna a lista.

O Picker na tela √© preenchido.

O usu√°rio seleciona uma especialidade e clica em "Ver profissionais".

VerProfissionaisCommand √© disparado.

Ponto Cr√≠tico: A navega√ß√£o agora envia DOIS par√¢metros: GoToAsync($"{nameof(MedicosDisponiveisPage)}?EspecialidadeNome={Nome}&IdProcedimento={IdProcedimento}").

Sele√ß√£o de M√©dico e Data (MedicosDisponiveisPage -> MedicosDisponiveisViewModel):

O ViewModel recebe EspecialidadeNome e IdProcedimento via [QueryProperty].

PageAppearingCommand chama GetMedicosAsync().

O servi√ßo faz um GET para /api/agendamento/medicos/{especialidade}. O backend filtra a AgendaWebView pelo nome da especialidade. O Picker de m√©dicos √© preenchido.

O usu√°rio seleciona um m√©dico. OnMedicoSelecionadoChanged √© disparado.

O m√©todo CarregarDiasDisponiveis() √© chamado. Ele cria um DiasDisponiveisRequest com o ID do m√©dico, m√™s e ano, e faz um POST para /api/agendamento/dias-disponiveis.

L√≥gica de Backend: O endpoint percorre cada dia do m√™s, consulta a AgendaWebView para ver se o m√©dico trabalha naquele dia da semana e se a QuantidadeMaxima > 0. Ele tamb√©m conta os agendamentos j√° existentes na Cad_Agenda para aquele dia e retorna uma lista de objetos com Dia e Status ("Disponivel", "PoucasVagas").

O calend√°rio na tela √© "aceso" com as cores verde e amarelo.

Sele√ß√£o de Hor√°rio e Confirma√ß√£o (Ainda em MedicosDisponiveisViewModel):

O usu√°rio clica num dia dispon√≠vel. SelecionarDiaCommand √© disparado.

Ele cria um HorariosDisponiveisRequest (com ID do m√©dico, a data e o IdProcedimento que recebemos) e faz um POST para /api/agendamento/horarios-disponiveis.

L√≥gica de Backend (O Algoritmo): Este √© o c√≥digo mais inteligente do sistema. Ele:

Busca as regras de hor√°rio (in√≠cio, fim, almo√ßo) e a dura√ß√£o da consulta (EscalaAgenda) da AgendaWebView.

Busca todos os hor√°rios j√° ocupados na Cad_Agenda para aquele dia.

Gera todos os "slots" de hor√°rio poss√≠veis (um while que incrementa a hora de in√≠cio pela dura√ß√£o da consulta).

Para cada slot, verifica se ele se sobrep√µe com algum hor√°rio j√° ocupado ou com o hor√°rio de almo√ßo.

Retorna uma lista de strings com os hor√°rios que sobraram (ex: "09:00", "09:30").

O carrossel de hor√°rios aparece na tela.

O usu√°rio clica num hor√°rio. SelecionarHorarioCommand √© disparado. A propriedade ShowAgendarButton vira true.

O bot√£o "Agendar Consulta" aparece com uma anima√ß√£o.

O usu√°rio clica em "Agendar Consulta". AgendarConsultaCommand √© disparado.

L√≥gica Final: O comando cria um AgendamentoRequestDto com todos os dados coletados: IdPaciente (do UserDataService), IdPrestadorMedico, DataHoraMarcada (combinando a data e a hora), e o IdProcedimento.

O servi√ßo faz um POST final para /api/agendamento. O backend cria uma nova linha na tabela Cad_Agenda e retorna 201 Created.

Se o resultado for true, o app navega para a AgendamentoSucessoPage.

Sucesso! (AgendamentoSucessoPage):

A tela √© exibida, mostrando o Image com a Source="success_checkmark.gif" e IsAnimationPlaying="True".

O bot√£o "Voltar para o In√≠cio" executa o comando VoltarCommand.

A navega√ß√£o Shell.Current.GoToAsync("//DashboardPage") reseta o fluxo, levando o usu√°rio de volta √† tela principal.

III. HIST√ìRICO DE GUERRA: BUGS CR√çTICOS ESMAGADOS
O Bug do Fechamento S√∫bito:

Sintoma: App fechava ao tentar navegar para a Dashboard ap√≥s o login.

Causa: A navega√ß√£o //DashboardPage √© uma navega√ß√£o absoluta que exige que a rota esteja registrada na hierarquia principal do AppShell.xaml. Nossa DashboardPage estava apenas registrada como uma rota secund√°ria.

Solu√ß√£o: Transformamos a DashboardPage no ShellContent principal ap√≥s o login, validando a rota absoluta.

O Bug do idProcedimentoTussNomenclatura Nulo:

Sintoma: Agendamento falhava no banco de dados com erro de FOREIGN KEY.

Causa: Est√°vamos passando IdProcedimento = 1 fixo, mas a especialidade/m√©dico selecionado podia n√£o ter rela√ß√£o com o procedimento de ID 1 na tabela Tab_ProcedimentoTussNomenclatura.

Solu√ß√£o: Passamos o IdProcedimento real desde a tela de especialidades at√© o ViewModel final, usando QueryProperty.

O Bug do Mapeamento de Nomes de Coluna:

Sintoma: Erro SQL Nome de coluna '...' inv√°lido. (Ex: EscalaAgendaEspecialidade).

Causa: A propriedade na nossa entidade C# (EscalaAgendaEspecialidade) n√£o correspondia ao nome da coluna na view do banco (EscalaAgenda).

Solu√ß√£o: Corrigimos o mapeamento na classe AgendaWebView.cs usando o atributo [Column("EscalaAgenda")] e renomeando a propriedade para public int? EscalaAgenda { get; set; }.

O Bug do Valor Nulo ( SqlNullValueException ):

Sintoma: API retornava erro 500 ao tentar ler dados do banco, especificamente em colunas de hor√°rio como SegundaHoraInicio.

Causa: O banco de dados permitia valores NULL para os hor√°rios, mas nossas propriedades na entidade AgendaWebView.cs eram string, que n√£o podem ser nulas por padr√£o no C# moderno.

Solu√ß√£o: Alteramos todas as propriedades que poderiam ser nulas no banco para tipos anul√°veis em C#: string? para os hor√°rios e int? para as quantidades.

Esta documenta√ß√£o encapsula o estado atual e a jornada do projeto. A pr√≥xima etapa √© a implementa√ß√£o da l√≥gica real para os hor√°rios de almo√ßo e outras regras de neg√≥cio complexas no algoritmo de horarios-disponiveis.