#REGRA SEMPRE SOLICITAR TODO OS ARQUIVOS DO PROJETO ATUAL PRA CONTINUAR O PROGRESSO DO APP PARA VOC√ä N√ÉO SE PERDE!!!

DOCUMENTA√á√ÉO T√âCNICA E ESTRAT√âGICA FINALPROJETO: GAMIR SA√öDE üöÄVers√£o Final: 5.2 (Agendamento Est√°vel, Autentica√ß√£o e Envio de E-mail em Produ√ß√£o)Autor: IGRIS V1.0 (Sistema de Intelig√™ncia T√°tica Integrada)Data: 17 de Outubro de 2025I. ARQUITETURA E FUNDA√á√ÉOO projeto segue estritamente o princ√≠pio de Separa√ß√£o Total de Responsabilidades, utilizando Clean Architecture no Backend e MVVM no Frontend.1.1. Backend: Clean Architecture (C# .NET 8)ProjetoProp√≥sitoEstrutura Cr√≠ticaGamirSaude.DomainO Cora√ß√£o Sagrado. Cont√©m as entidades, interfaces e as leis do universo.Interfaces: IPacienteRepository, IEmailService. Entidades: Agenda, Paciente, Cad_UsuarioApp.GamirSaude.ApplicationA Camada T√°tica. Cont√©m a l√≥gica de neg√≥cio principal e todos os DTOs (Contratos de Comunica√ß√£o).AgendamentoRequestDto, LoginRequestDto, VerifyCodeRequestDto.GamirSaude.InfrastructureA Sala de M√°quinas. Cont√©m as implementa√ß√µes concretas e a conex√£o com o mundo exterior.Repositories/PacienteRepository.cs. Services/EmailService.cs (Implementa√ß√£o concreta do envio de e-mail). GamirSaudeDbContext.cs (Mapeamento de todas as tabelas e Views).GamirSaude.APIA Linha de Frente. Exp√µe os Controllers e registra todos os servi√ßos via Program.cs.AuthController.cs (Autentica√ß√£o/Verifica√ß√£o). AgendamentoController.cs (L√≥gica de Agendamento/Slots).1.2. Frontend: .NET MAUI (MVVM)CamadaProp√≥sitoEstrutura Cr√≠ticaViewModelsO C√©rebro. L√≥gica de UI e comandos. Todos herdam de BaseViewModel.LoginViewModel, DashboardViewModel, MedicosDisponiveisViewModel.ServicesGerenciamento de Estado e Comunica√ß√£o.UserDataService.cs (Armazena o estado do usu√°rio logado). GamirApiService.cs (Todas as chamadas REST).ViewsInterface do Usu√°rio (.xaml). Todas as p√°ginas de agendamento e autentica√ß√£o.LoginPage.xaml, RegisterPage.xaml, VerifyAccountPage.xaml.II. FLUXOS DE NEG√ìCIO DETALHADOS2.1. Fluxo de Cadastro (Blindagem e Seguran√ßa)ComponenteFuncionalidade DetalhadaFrontend (RegisterViewModel)Coleta dados (Nome, CPF, E-mail, etc.). Utiliza Behaviors no RegisterPage.xaml para formata√ß√£o visual (CPF, Telefone). Aplica a limpeza (.Where(char.IsDigit)) e formata√ß√£o (.Substring(0, 1)) nos dados antes do envio para a API.Backend (AuthController.cs)1. Valida√ß√£o: Verifica unicidade de CPF e E-mail. 2. Seguran√ßa: Cria o Hash BCrypt (BCrypt.Net.BCrypt.HashPassword) da senha. 3. Persist√™ncia: Salva o novo usu√°rio na tabela Cad_UsuarioApp com ContaVerificada = false e idPacienteGamir = null.2.2. Fluxo de LoginComponenteFuncionalidade DetalhadaFrontend (LoginViewModel)Usa GetCpfNumerico() para garantir que o CPF seja enviado sem formata√ß√£o.Backend (AuthController.cs)1. Busca: Localiza o usu√°rio em Cad_UsuarioApp. 2. Verifica√ß√£o: Utiliza BCrypt.Net.BCrypt.Verify() para comparar a senha digitada com o hash salvo. 3. Resposta: Em caso de sucesso, retorna o status da conta, incluindo ContaVerificada e o idPacienteGamir.UserDataService.csGest√£o de Estado: Armazena o estado completo do usu√°rio logado. A propriedade IdPaciente √© definida como IdPacienteGamir ?? 0, sendo o valor que alimenta todas as requisi√ß√µes de agendamento.2.3. Fluxo de Verifica√ß√£o de Conta (A Ponte Cr√≠tica)ComponenteFuncionalidade DetalhadaFrontend (DashboardViewModel)Guardi√£o de Port√£o: Implementado um bloqueio de acesso nos comandos AgendarConsultaCommand e AgendarExameCommand. Se _userDataService.ContaVerificada for false, exibe um DisplayAlert e impede a navega√ß√£o para as telas de agendamento.Frontend (VerifyAccountViewModel)Envio de C√≥digo: Comando SendCode chama a API, passando o E-mail do usu√°rio logado. Verifica√ß√£o: Comando Verify envia o c√≥digo digitado. Se for um sucesso, atualiza o status localmente e navega para a Dashboard com o par√¢metro ?refresh=true para remover o aviso.Backend (AuthController.cs)Envio (Real): Recebe a requisi√ß√£o, gera um c√≥digo de 6 d√≠gitos e a DataExpiracaoCodigo (15 minutos). Chama o IEmailService para o envio real. Valida√ß√£o: Checa validade e expira√ß√£o do c√≥digo. Cria√ß√£o da Ponte: Se tudo estiver OK, busca o IdPaciente na tabela legado (_context.Pacientes) usando o e-mail. Atribui usuarioApp.idPacienteGamir = pacienteLegado.IdPaciente.EmailService.csProdu√ß√£o: Implementa√ß√£o de envio SMTP real usando a classe SmtpClient. As credenciais (Host, Port, User, Password) s√£o carregadas de forma segura do appsettings.json via inje√ß√£o de IConfiguration, eliminando o hardcode e a falha do EmailJS. Configura√ß√£o: Usa smtp.gmail.com, porta 587 e EnableSsl = true, exigindo uma Senha de Aplicativo do Google para funcionar.2.4. Fluxo de Agendamento (Transa√ß√£o e Reutiliza√ß√£o)ComponenteFuncionalidade DetalhadaReutiliza√ß√£o de TelaA tela MedicosDisponiveisPage √© reutilizada para Consultas e Exames.Transfer√™ncia de IDO AgendarConsultaViewModel e o ExamesEspecificosViewModel navegam para a pr√≥xima tela passando o IdProcedimento e o EspecialidadeNome via [QueryProperty].L√≥gica de Slots (AgendamentoController)Os endpoints dias-disponiveis e horarios-disponiveis usam a AgendaWebView para calcular slots dinamicamente, considerando a EscalaAgenda (dura√ß√£o do slot) e o intervalo de almo√ßo, com l√≥gica otimizada para avan√ßar o ponteiro de tempo corretamente.Transa√ß√£o FinalO AgendarConsultaCommand no MedicosDisponiveisViewModel envia o IdPaciente (garantido como v√°lido pelo Guardi√£o), IdPrestadorMedico, DataHoraMarcada e o IdProcedimento para a API.Persist√™ncia (AgendamentoController)O endpoint [HttpPost] AgendarConsulta insere diretamente o registro na tabela Cad_Agenda. Esta l√≥gica simples substitui a complexa Procedure legada e √© funcional porque o sistema fornece o IdPaciente v√°lido e a regra de ser "Particular" (IDs 33/31) √© resolvida no Backend.Esta documenta√ß√£o resume todo o esfor√ßo de desenvolvimento e valida a estabilidade da arquitetura do projeto.