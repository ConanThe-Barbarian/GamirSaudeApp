 DOCUMENTA√á√ÉO MESTRA DE PROJETO: A SAGA DO APLICATIVO GAMIR SA√öDE üöÄ
Vers√£o: 4.0 (Marco: Fluxo de Agendamento Din√¢mico Conclu√≠do)
Data: 14 de Outubro de 2025
Autor: VORTEX V3.0 (Arquiteto de Solu√ß√µes e Mentor Full-Stack)
Prop√≥sito: Este documento √© o registro definitivo e absurdamente detalhado da jornada de desenvolvimento do aplicativo Gamir Sa√∫de. Ele disseca a arquitetura, o c√≥digo-fonte, as decis√µes cr√≠ticas e o hist√≥rico de cada bug esmagado, servindo como a fonte da verdade absoluta para qualquer desenvolvedor ou IA que assuma este legado.

I. FILOSOFIA E ARQUITETURA GERAL: A FUNDA√á√ÉO
A estrat√©gia desde o in√≠cio foi a separa√ß√£o total de responsabilidades. O sistema √© dividido em duas fortalezas que se comunicam por uma ponte RESTful.

1.1. O Backend (API RESTful): O C√©rebro de A√ßo
Constru√≠do com .NET 8, C# 12 e Entity Framework Core 8, ele segue a Clean Architecture, uma disciplina de guerra que garante que a l√≥gica de neg√≥cio n√£o seja contaminada por detalhes de infraestrutura.

GamirSaude.Domain (O Cora√ß√£o Sagrado):

Prop√≥sito: Cont√©m as leis do nosso universo. As classes de Entidades (espelhos das tabelas do banco) e as Interfaces de reposit√≥rios vivem aqui. Este projeto n√£o conhece e n√£o depende de ningu√©m.

Classes Cruciais Criadas: Paciente.cs, Especialidade.cs, PrestadorMedico.cs, Agenda.cs, e as mais importantes: AgendaWebView.cs (para as regras de agendamento) e AgendaView.cs (para o hist√≥rico de agendamentos).

Mapeamento de Dados: Usamos "Data Annotations" ([Table], [Key], [Column]) para mapear precisamente as classes C# √†s tabelas e colunas com nomes legados do banco SQL Server. Esta foi a chave para resolver 90% dos erros de banco de dados.

GamirSaude.Infrastructure (As Ferramentas Pesadas):

Prop√≥sito: A sala de m√°quinas. Cont√©m o GamirSaudeDbContext.cs, que √© o tradutor oficial entre C# e SQL, e as implementa√ß√µes concretas dos reposit√≥rios. √â aqui que o Entity Framework Core faz sua m√°gica.

GamirSaude.Application (O T√°tico):

Prop√≥sito: Onde a estrat√©gia √© definida. Cont√©m a l√≥gica de neg√≥cio e, crucialmente, os DTOs (Data Transfer Objects).

Pastas Criadas: DTOs.

Classes Cruciais Criadas: DiasDisponiveisRequest.cs, HorariosDisponiveisRequest.cs, AgendamentoRequestDto.cs. Estas classes s√£o os "envelopes" que carregam as informa√ß√µes entre o frontend e o backend.

GamirSaude.API (A Linha de Frente):

Prop√≥sito: A interface com o mundo exterior. Exp√µe os Controllers e seus Endpoints (as URLs que o nosso app chama).

Controllers Criados: AuthController.cs e AgendamentoController.cs.

1.2. O Frontend (App M√≥vel): A Experi√™ncia do Usu√°rio
Constru√≠do com .NET MAUI, ele segue o padr√£o MVVM (Model-View-ViewModel), garantindo que a interface (View) seja completamente "burra", apenas um reflexo do estado do seu c√©rebro (ViewModel).

Models: Classes simples que s√£o moldes para os dados da API (ex: Medico.cs, TipoExame.cs).

Views: As telas, constru√≠das em XAML. Cont√™m a apar√™ncia e o layout.

ViewModels: O c√©rebro de cada tela. Cont√©m toda a l√≥gica e estado (propriedades). Usamos a biblioteca CommunityToolkit.Mvvm para acelerar com os atributos [ObservableProperty] e [RelayCommand].

Services: A camada de comunica√ß√£o. GamirApiService.cs √© nosso ponto de contato com o backend. UserDataService.cs √© a mem√≥ria global que guarda os dados do paciente logado.

Converters: Utilit√°rios para transformar dados no XAML (ex: InverseBoolConverter).

II. A JORNADA DE CONSTRU√á√ÉO: CADA TABELA, CADA CLIQUE
2.1. A Tabela Mestra: vw_cad_prestadorMedicoEspecialidadeAgendaWeb
Esta VIEW no SQL Server se tornou a espinha dorsal de todo o fluxo de agendamento. Ap√≥s diversas refatora√ß√µes, ela agora √© um JOIN completo que une m√∫ltiplas tabelas (Cad_PrestadorMedico, Cad_PrestadorMedicoEspecialidade, Cad_ANSCbos, Cad_PrestadorMedicoEspecialidadeProcedimento, Tab_ProcedimentoTussNomenclatura) e cont√©m todas as regras de neg√≥cio em um s√≥ lugar:

Dados do m√©dico (PrestadorMedico)

Dados da especialidade (EspecialidadeCBOS)

Agrupador de Exames: A crucial coluna DescricaoAgenda.

Descri√ß√£o Espec√≠fica do Procedimento: A coluna PTNDescricaoTuss.

Valor do Procedimento: A coluna PTNValCustoProcedimento (renomeada como Valor).

Regras de expediente: Dias da semana que trabalha (Segunda, Terca), hor√°rios de in√≠cio, fim e almo√ßo.

Regras de capacidade: Quantidade m√°xima de agendamentos por dia (SegundaQuantidadeMaxima).

Dura√ß√£o da consulta: O campo EscalaAgendaEspecialidade (renomeado como EscalaAgenda).

Li√ß√£o Aprendida: Centralizar a l√≥gica de busca de regras em uma View robusta no banco de dados simplifica drasticamente o c√≥digo C#, melhora a performance e facilita a manuten√ß√£o.

2.2. O Fluxo de Agendamento de Consultas (100% Funcional)
Login e Dashboard: Autentica√ß√£o e navega√ß√£o inicial. O UserDataService (Singleton) armazena o ID e nome do paciente.

Sele√ß√£o de Especialidade (AgendarConsultaPage): O PageAppearingCommand chama GET /api/agendamento/especialidades. O endpoint l√™ a AgendaWebView, retorna uma lista √∫nica de especialidades com seus IdProcedimento associados.

Navega√ß√£o para M√©dicos: Ao selecionar uma especialidade, o VerProfissionaisCommand navega para MedicosDisponiveisPage, passando EspecialidadeNome e IdProcedimento como par√¢metros de rota.

Sele√ß√£o de M√©dico, Dia e Hora (MedicosDisponiveisPage): A tela carrega os m√©dicos daquela especialidade. Ao selecionar um m√©dico, o calend√°rio √© preenchido dinamicamente via POST /dias-disponiveis. Ao selecionar um dia, os hor√°rios s√£o preenchidos via POST /horarios-disponiveis.

Agendamento: O AgendarConsultaCommand envia todos os dados (incluindo IdPaciente do UserDataService) para o endpoint POST /api/agendamento, que cria uma nova linha na tabela Cad_Agenda.

Sucesso: O app navega para a AgendamentoSucessoPage, que exibe uma anima√ß√£o GIF.

2.3. O Fluxo de Agendamento de Exames (Em Constru√ß√£o)
Dashboard: O bot√£o "Agendar Exame" agora navega para a nova AgendarExamePage.

Sele√ß√£o do TIPO de Exame (AgendarExamePage): A tela carrega com um Picker. O PageAppearingCommand chama o novo endpoint GET /api/agendamento/exames/tipos, que l√™ a coluna DescricaoAgenda da AgendaWebView para popular o Picker (ex: "DENSITOMETRIA", "MAMOGRAFIA").

Pr√≥ximo Passo (Onde Paramos): Ao clicar em "Ver exames dispon√≠veis", o ViewModel est√° pronto para navegar para a ExamesEspecificosPage, passando o nome do tipo de exame selecionado.

III. HIST√ìRICO DE GUERRA: BUGS CR√çTICOS ESMAGADOS
O Bug da "Mem√≥ria" (Singleton vs. Transient): Telas de agendamento guardavam dados antigos. Solu√ß√£o: Alteramos o registro de DI das p√°ginas e ViewModels de AddSingleton para AddTransient no MauiProgram.cs.

O Bug da Tela Branca (A "Cola"): Novas telas navegavam, mas apareciam vazias. Causa: Falta do c√≥digo no arquivo .xaml.cs para injetar o ViewModel no BindingContext e para executar o PageAppearingCommand no evento OnAppearing.

O Bug do HotReloadException: API quebrava ap√≥s alterarmos a assinatura de um m√©todo. Solu√ß√£o: Disciplina de Parar (Shift+F5), Recompilar e Executar (F5) sempre que a assinatura de um endpoint da API √© alterada.

O Bug do Mapeamento SQL (Nome de coluna inv√°lido): A API falhava ao tentar ler colunas que n√£o existiam na View ou tinham nomes diferentes. Solu√ß√£o: Atualizamos a VIEW no SQL Server para incluir todas as colunas necess√°rias (PTNDescricaoTuss, PTNValCustoProcedimento) e usamos aliases (AS) para compatibilizar nomes (Descricao AS DescricaoAgenda).

O Bug da "Perda de Contexto": Selecionar "Consulta" (ID 1) para um Geriatra listava m√©dicos de todas as especialidades. Solu√ß√£o: Refatoramos o endpoint de busca de profissionais para aceitar um filtro duplo: GET /exames/profissionais/{especialidade}/{idProcedimento}, garantindo a precis√£o da busca.

IV. PR√ìXIMOS PASSOS IMEDIATOS: A CONQUISTA DO FLUXO DE EXAMES
Nossa posi√ß√£o √© forte. O backend est√° pronto e a primeira tela de exames funciona. A pr√≥xima fase da opera√ß√£o √©:

Construir a Tela de Exames Espec√≠ficos: Implementar o XAML da ExamesEspecificosPage para exibir a lista de exames que v√™m do endpoint GET /exames/especificos/{tipoExame}.

Implementar a L√≥gica de Valor: Adicionar a l√≥gica de exibi√ß√£o do valor do exame e o bot√£o de confirma√ß√£o, como planejado.

Conectar a Navega√ß√£o Final: Fazer com que o bot√£o "Confirmar e ver profissionais" navegue para a tela MedicosDisponiveisPage, passando os par√¢metros EspecialidadeNome (que neste fluxo ser√° o nome do exame espec√≠fico) e IdProcedimento.

Teste de Reutiliza√ß√£o: Validar que a tela MedicosDisponiveisPage funciona perfeitamente com os dados do fluxo de exames, reutilizando toda a l√≥gica de calend√°rio e hor√°rios que j√° constru√≠mos.

A vit√≥ria est√° ao nosso alcance. AVAN√áAR!